module core_tests
  use mod_global_variables
  use funit
  implicit none

  real(dp), parameter   :: TOL = 1.0d-12

contains

  @before
  subroutine init_test()
    ! reset variables to their default values
    call initialise_globals()
    ! disable logging except for errors
    logging_level = 0
  end subroutine init_test


  @after
  subroutine teardown()
    use mod_grid, only: grid, grid_clean
    use mod_equilibrium, only: rho_field, equilibrium_clean

    if (allocated(grid)) then
      call grid_clean()
    end if
    if (allocated(rho_field % rho0)) then
      call equilibrium_clean()
    end if
  end subroutine teardown


  subroutine create_test_grid(pts, geom)
    use mod_grid, only: initialise_grid

    integer, intent(in) :: pts
    character(len=*)    :: geom

    geometry = geom
    x_start = 0.0d0
    x_end = 1.0d0
    call set_gridpts(pts)
    call initialise_grid()
  end subroutine create_test_grid


  @test
  subroutine test_gamma()
    real(dp), parameter :: gamma_test = 5.0d0 / 3.0d0
    real(dp), parameter :: gamma_test_1 = gamma_test - 1.0d0

    write(*, *) "Testing gamma setters"
    call set_gamma(gamma_test)
    @assertEqual(gamma_test, gamma, tolerance=TOL)
    @assertEqual(gamma_test_1, gamma_1, tolerance=TOL)
  end subroutine test_gamma

  @test
  subroutine test_gridpts()
    integer, parameter :: gridpts_test = 11

    write(*, *) "Testing gridpoints"
    call set_gridpts(gridpts_test)
    @assertEqual(gridpts_test, gridpts)
    @assertEqual(40, gauss_gridpts)
    @assertEqual(176, matrix_gridpts)
    @assertEqual(21, ef_gridpts)
  end subroutine test_gridpts


  @test
  subroutine test_cart_grid()
    use mod_grid, only: grid

    write(*, *) "Testing Cartesian grid edges"
    call create_test_grid(31, 'Cartesian')
    @assertEqual(x_start, grid(1), tolerance=TOL)
    @assertEqual(x_end, grid(gridpts), tolerance=TOL)
  end subroutine test_cart_grid


  @test
  subroutine test_cyl_grid()
    use mod_grid, only: grid

    write(*, *) "Testing cylindrical grid edges"
    call create_test_grid(31, 'cylindrical')
    @assertGreaterThan(grid(1), 2.0d-2)
    @assertEqual(grid(gridpts), x_end, tolerance=TOL)
  end subroutine test_cyl_grid


  @test
  subroutine test_cyl_grid_forced()
    use mod_grid, only: grid

    write(*, *) "Testing cylindrical grid edges (forced)"
    force_r0 = .true.
    call create_test_grid(31, 'cylindrical')
    @assertEqual(grid(1), 0.0d0, tolerance=TOL)
    @assertEqual(grid(gridpts), x_end, tolerance=TOL)
  end subroutine test_cyl_grid_forced


  @test
  subroutine test_grid_monotonicity()
    use mod_grid, only: grid_clean, grid

    integer   :: idx

    write(*, *) "Testing grid monotonicity"
    call create_test_grid(31, 'Cartesian')
    do idx = 1, gridpts-1
      @assertLessThan(grid(idx), grid(idx+1))
    end do
    call grid_clean()
  end subroutine test_grid_monotonicity


  @test
  subroutine test_grid_gauss_monotonicity()
    use mod_grid, only: grid_clean, grid_gauss

    integer   :: idx

    write(*, *) "Testing grid_gauss monotonicity"
    call create_test_grid(31, 'Cartesian')
    do idx = 1, gauss_gridpts-1
      @assertLessThan(grid_gauss(idx), grid_gauss(idx+1))
    end do
    call grid_clean()
  end subroutine test_grid_gauss_monotonicity


  @test
  subroutine test_matrix_inversion()
    use mod_solvers, only: invert_B

    real(dp)  :: matrix(4, 4), matrix_inverse(4, 4), expected(4, 4)
    integer   :: i, j

    write(*, *) "Testing matrix inversion"
    call set_matrix_gridpts(4)
    matrix    = reshape((/ 7,  0, -3,  2,   &   ! column 1
                           2,  3,  4,  2,   &   ! column 2
                           1, -1, -2, -1,   &
                          -2,  2,  1,  4 /), shape(matrix))
    expected  = reshape((/ 1.0d0/7.0d0,   0.0d0,        -2.0d0/7.0d0,   -1.0d0/7.0d0,    &
                          -4.0d0/7.0d0,   1.0d0,        22.0d0/7.0d0,    4.0d0/7.0d0,    &
                          10.0d0/49.0d0, -2.0d0/7.0d0, -76.0d0/49.0d0, -17.0d0/49.0d0,   &
                          15.0d0/49.0d0, -3.0d0/7.0d0, -65.0d0/49.0d0, -1.0d0/49.0d0 /), &
                          shape(expected))
    call invert_B(matrix, matrix_inverse)
    @assertEqual(matrix_inverse, expected, tolerance=TOL)
  end subroutine test_matrix_inversion


  @test
  subroutine test_matrix_multiplication()
    use mod_solvers, only: get_B_invA

    real(dp)     :: matrixB(4, 4)
    complex(dp)  :: matrixA(4, 4), multiplication_result(4, 4), expected(4, 4)
    integer      :: i, j

    write(*, *) "Testing matrix multiplication"
    call set_matrix_gridpts(4)
    matrixB = reshape((/ 7.0d0,  0.0d0, -3.0d0,  2.0d0,   &  ! column 1
                         2.0d0,  3.0d0,  4.0d0,  2.0d0,   &  ! column 2
                         1.0d0, -1.0d0, -2.0d0, -1.0d0,   &
                        -2.0d0,  2.0d0,  1.0d0,  4.0d0 /), shape(matrixB))
    matrixA = reshape((/ 2.0d0*ir,  0.0d0*ir,  1.0d0*ic, -3.0d0*ir, &
                         3.0d0*ir,  0.0d0*ir,  2.0d0*ic,  1.0d0*ir, &
                         4.0d0*ic,  3.0d0*ir, -7.0d0*ir,  5.0d0*ic, &
                        -1.0d0*ir, -2.0d0*ir,  3.0d0*ir,  2.0d0*ir /), shape(matrixA))
    expected = reshape((/ ( 20.0d0, 1.0d0), (-6.0d0,-1.0d0), (-9.0d0,-2.0d0), (-8.0d0,-1.0d0),   &
                          ( 19.0d0, 2.0d0), ( 2.0d0,-2.0d0), (-8.0d0,-4.0d0), (10.0d0,-2.0d0),   &
                          ( -1.0d0,18.0d0), (16.0d0,10.0d0), (26.0d0,-7.0d0), (13.0d0,28.0d0),   &
                          (-12.0d0, 0.0d0), (-5.0d0, 0.0d0), (-9.0d0, 0.0d0), (-1.0d0, 0.0d0)/), &
                       shape(expected))
    call get_B_invA(matrixB, matrixA, multiplication_result)
    @assertEqual(multiplication_result, expected, tolerance=TOL)
  end subroutine test_matrix_multiplication


  @test
  subroutine test_matrix_qr_solver()
    use mod_solvers, only: solve_QR

    real(dp)    :: matrixB(4, 4)
    complex(dp) :: matrixA(4, 4), eigenvals(4), eigenvals_solution(4)
    complex(dp) :: vl(4, 4), vr(4, 4), temp
    integer     :: i, j, minidx

    write(*, *) "Testing matrix QR solver"
    call set_matrix_gridpts(4)
    ! define identity matrix for convenience, inversion is already tested here
    do i = 1, 4
      do j = 1, 4
        if (i == j) then
          matrixB(j, i) = 1.0d0
        else
          matrixB(j, i) = 0.0d0
        end if
      end do
    end do
    matrixA = reshape((/  2.0d0*ir, -1.0d0*ir, 0.0d0*ir,  0.0d0*ir, &
                          9.0d0*ir,  2.0d0*ir, 0.0d0*ir,  0.0d0*ir, &
                          0.0d0*ir,  1.0d0*ir, 3.0d0*ir,  1.0d0*ir, &
                          2.0d0*ir,  0.0d0*ir, 0.0d0*ir, -1.0d0*ir/), shape(matrixA))
    call solve_QR(matrixA, matrixB, eigenvals, vl, vr)
    !! sort eigenvalues (using selection sort, based on real part)
    do i = 1, size(eigenvals)-1
      minidx = minloc(real(eigenvals(i:)), 1) + i - 1
      if (real(eigenvals(i)) > real(eigenvals(minidx))) then
        temp = eigenvals(i)
        eigenvals(i) = eigenvals(minidx)
        eigenvals(minidx) = temp
      end if
    end do
    eigenvals_solution =  (/ (-1.0d0, 0.0d0), (2.0d0, -3.0d0), &
                          ( 2.0d0, 3.0d0), (3.0d0,  0.0d0) /)
    @assertEqual(eigenvals, eigenvals_solution, tolerance=TOL)
  end subroutine test_matrix_qr_solver


  @test
  subroutine test_subblock_fill()
    use mod_global_variables, only: dim_quadblock
    use mod_make_subblock, only: subblock

    complex(dp) :: quadblock(dim_quadblock, dim_quadblock)
    complex(dp) :: factors(2), val1, val2
    real(dp)    :: spline1(4), spline2(4), weight
    integer     :: positions(2, 2), i, idx1(16), idx2(16)

    write(*, *) "Testing subblock filling"
    quadblock = (0.0d0, 0.0d0)
    val1 = (3.0d0, 1.0d0)
    val2 = (-1.0d0, 5.0d0)
    !! Two factors and positions are chosen freely
    factors(1) = val1
    positions(1, :) = [4, 3]
    factors(2) = val2
    positions(2, :) = [7, 5]
    !! weight and splines are set to unity for testing purposes
    weight = 1.0d0
    spline1 = 1.0d0
    spline2 = 1.0d0
    call subblock(quadblock, factors, positions, weight, spline1, spline2)
    !! first factor
    idx1 = (/ 7, 7, 8, 8,  7,  7,  8,  8, 23, 23, 24, 24, 23, 23, 24, 24 /)
    idx2 = (/ 5, 6, 5, 6, 21, 22, 21, 22,  5,  6,  5,  6, 21, 22, 21, 22 /)
    do i = 1, size(idx1)
      @assertEqual(quadblock(idx1(i), idx2(i)), val1, tolerance=TOL)
    end do
    ! !! second factor
    idx1 = (/ 13, 13, 14, 14, 13, 13, 14, 14, 29, 29, 30, 30, 29, 29, 30, 30 /)
    idx2 = (/  9, 10,  9, 10, 25, 26, 25, 26,  9, 10,  9, 10, 25, 26, 25, 26 /)
    do i = 1, size(idx1)
      @assertEqual(quadblock(idx1(i), idx2(i)), val2, tolerance=TOL)
    end do
  end subroutine test_subblock_fill


  @test
  subroutine test_bcs_cart_wall()
    use mod_boundary_conditions, only: apply_boundary_conditions
    use mod_equilibrium, only: initialise_equilibrium, set_equilibrium

    complex(dp) :: matrix_A(176, 176)
    real(dp)    :: matrix_B(176, 176), matrix_B_expected(176, 176)
    real(dp)    :: quadblock(32, 32)
    integer     :: zero_idxs(5), left_wall(3), right_wall(3)
    integer     :: i, j, k

    write(*, *) "Testing Cartesian geometry, fixed wall BCs"
    geometry = 'Cartesian'
    thermal_conduction = .false.
    boundary_type = 'wall'
    equilibrium_type = 'resistive_tearing_flow'
    call set_gridpts(11)
    call initialise_equilibrium()
    call set_equilibrium()
    @assertEqual(matrix_gridpts, 176)
    matrix_A = (0.0d0, 0.0d0)
    matrix_B = 5.0d0
    matrix_B_expected = 5.0d0
    call apply_boundary_conditions(matrix_A, matrix_B)

    quadblock = 5.0
    ! zero contributions from the quadratic basis functions
    zero_idxs = [1, 5, 7, 9, 11]
    do i = 1, size(zero_idxs)
      j = zero_idxs(i)
      quadblock(j, j) = 1.0d0
    end do
    ! left wall boundary conditions
    left_wall = [3, 13, 15]
    do i = 1, size(left_wall)
      j = left_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(1:32, 1:32) = quadblock

    ! reset quadblock
    quadblock = 5.0d0
    right_wall = [19, 29, 31]
    do i = 1, size(right_wall)
      j = right_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(145:176, 145:176) = quadblock
    @assertEqual(matrix_B, matrix_B_expected, tolerance=TOL)
  end subroutine test_bcs_cart_wall

  @test
  subroutine test_bcs_cyl_wall()
    use mod_boundary_conditions, only: apply_boundary_conditions
    use mod_equilibrium, only: initialise_equilibrium, set_equilibrium

    complex(dp) :: matrix_A(176, 176)
    real(dp)    :: matrix_B(176, 176), matrix_B_expected(176, 176)
    real(dp)    :: quadblock(32, 32)
    integer     :: zero_idxs(5), left_wall(3), right_wall(3)
    integer     :: i, j, k

    write(*, *) "Testing cylindrical geometry, fixed wall BCs"
    geometry = 'cylindrical'
    thermal_conduction = .false.
    boundary_type = 'wall'
    equilibrium_type = 'suydam_cluster'
    call set_gridpts(11)
    call initialise_equilibrium()
    call set_equilibrium()
    @assertEqual(matrix_gridpts, 176)
    matrix_A = (0.0d0, 0.0d0)
    matrix_B = 5.0d0
    matrix_B_expected = 5.0d0
    call apply_boundary_conditions(matrix_A, matrix_B)

    quadblock = 5.0
    ! zero contributions from the quadratic basis functions
    zero_idxs = [1, 5, 7, 9, 11]
    do i = 1, size(zero_idxs)
      j = zero_idxs(i)
      quadblock(j, j) = 1.0d0
    end do
    ! on-axis regularity conditions
    left_wall = [3, 13, 15]
    do i = 1, size(left_wall)
      j = left_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(1:32, 1:32) = quadblock

    ! reset quadblock
    quadblock = 5.0d0
    right_wall = [19, 29, 31]
    do i = 1, size(right_wall)
      j = right_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(145:176, 145:176) = quadblock
    @assertEqual(matrix_B, matrix_B_expected, tolerance=TOL)
  end subroutine test_bcs_cyl_wall

  @test
  subroutine test_bcs_cart_wall_kappa()
    use mod_boundary_conditions, only: apply_boundary_conditions
    use mod_equilibrium, only: initialise_equilibrium, set_equilibrium

    complex(dp) :: matrix_A(176, 176)
    real(dp)    :: matrix_B(176, 176), matrix_B_expected(176, 176)
    real(dp)    :: quadblock(32, 32)
    integer     :: zero_idxs(5), left_wall(4), right_wall(4)
    integer     :: i, j

    write(*, *) "Testing Cartesian geometry, fixed wall BCs with conduction"
    geometry = 'Cartesian'
    thermal_conduction = .true.
    use_fixed_tc_perp = .true.
    fixed_tc_perp_value = 1.0d0
    boundary_type = 'wall'
    equilibrium_type = 'resistive_tearing_flow'
    call set_gridpts(11)
    call initialise_equilibrium()
    call set_equilibrium()
    @assertEqual(matrix_gridpts, 176)
    matrix_A = (0.0d0, 0.0d0)
    matrix_B = 5.0d0
    matrix_B_expected = 5.0d0
    call apply_boundary_conditions(matrix_A, matrix_B)

    quadblock = 5.0
    ! zero contributions from the quadratic basis functions
    zero_idxs = [1, 5, 7, 9, 11]
    do i = 1, size(zero_idxs)
      j = zero_idxs(i)
      quadblock(j, j) = 1.0d0
    end do
    ! left wall boundary conditions
    left_wall = [3, 13, 15, 9]
    do i = 1, size(left_wall)
      j = left_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(1:32, 1:32) = quadblock

    ! reset quadblock
    quadblock = 5.0d0
    right_wall = [19, 29, 31, 26]
    do i = 1, size(right_wall)
      j = right_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(145:176, 145:176) = quadblock
    @assertEqual(matrix_B, matrix_B_expected, tolerance=TOL)
  end subroutine test_bcs_cart_wall_kappa


  @test
  subroutine test_bcs_cyl_wall_kappa()
    use mod_boundary_conditions, only: apply_boundary_conditions
    use mod_equilibrium, only: initialise_equilibrium, set_equilibrium

    complex(dp) :: matrix_A(176, 176)
    real(dp)    :: matrix_B(176, 176), matrix_B_expected(176, 176)
    real(dp)    :: quadblock(32, 32)
    integer     :: zero_idxs(5), left_wall(4), right_wall(4)
    integer     :: i, j, k

    write(*, *) "Testing cylindrical geometry, fixed wall BCs with conduction"
    geometry = 'cylindrical'
    thermal_conduction = .true.
    use_fixed_tc_perp = .true.
    fixed_tc_perp_value = 1.0d0
    boundary_type = 'wall'
    equilibrium_type = 'suydam_cluster'
    call set_gridpts(11)
    call initialise_equilibrium()
    call set_equilibrium()
    @assertEqual(matrix_gridpts, 176)
    matrix_A = (0.0d0, 0.0d0)
    matrix_B = 5.0d0
    matrix_B_expected = 5.0d0
    call apply_boundary_conditions(matrix_A, matrix_B)

    quadblock = 5.0
    ! zero contributions from the quadratic basis functions
    zero_idxs = [1, 5, 7, 9, 11]
    do i = 1, size(zero_idxs)
      j = zero_idxs(i)
      quadblock(j, j) = 1.0d0
    end do
    ! on-axis regularity conditions
    left_wall = [3, 13, 15, 9]
    do i = 1, size(left_wall)
      j = left_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(1:32, 1:32) = quadblock

    ! reset quadblock
    quadblock = 5.0d0
    right_wall = [19, 29, 31, 26]
    do i = 1, size(right_wall)
      j = right_wall(i)
      quadblock(j, :) = 0.0d0
      quadblock(:, j) = 0.0d0
      quadblock(j, j) = 1.0d0
    end do
    matrix_B_expected(145:176, 145:176) = quadblock
    @assertEqual(matrix_B, matrix_B_expected, tolerance=TOL)
  end subroutine test_bcs_cyl_wall_kappa

end module core_tests
