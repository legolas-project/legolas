module comparison_tests
  use mod_global_variables, only: dp, matrix_gridpts
  use funit 
  implicit none
  
  integer, parameter    :: test_gridpts = 101
  integer, parameter    :: omega_base_unit = 10
  real(dp), parameter   :: TOL = 1.0d-9
  
  character(len=21), parameter  :: results_folder = "correct_test_results/"
  
contains 
  
  
  @before
  subroutine init_test()
    use mod_global_variables, only: set_gridpts
    use mod_equilibrium, only: initialise_equilibrium, set_equilibrium
    use mod_equilibrium_derivatives, only: initialise_equilibrium_derivatives
    use mod_input, only: read_parfile
    
    ! This sets all default values 
    call read_parfile("")
    call set_gridpts(test_gridpts)
    call initialise_equilibrium()
    call initialise_equilibrium_derivatives()
  end subroutine init_test
  
  
  @after 
  subroutine teardown_test()
    use mod_grid, only: grid_clean
    use mod_equilibrium, only: equilibrium_clean
    use mod_equilibrium_derivatives, only: equilibrium_derivatives_clean
    use mod_global_variables, only: radiative_cooling
    use mod_radiative_cooling, only: radiative_cooling_clean
    
    call grid_clean()
    call equilibrium_clean()
    call equilibrium_derivatives_clean()
    if (radiative_cooling) then 
      call radiative_cooling_clean()
    end if
  end subroutine teardown_test
  
  
  subroutine read_stored_eigenvals(filename, omega_base)
    character(len=*), intent(in)  :: filename 
    complex(dp), intent(out)      :: omega_base(matrix_gridpts)
    
    open(unit=omega_base_unit, file=filename, access='stream', status='old', action='read')
    read(unit=omega_base_unit) omega_base
    close(unit=omega_base_unit)
  end subroutine read_stored_eigenvals
  
  
  subroutine sort_array(array)
    real(dp), intent(inout)  :: array(matrix_gridpts)
    real(dp)                 :: temp
    integer                  :: i, minidx
    
    do i = 1, size(array)-1
      minidx = minloc(array(i:), 1) + i - 1
      if (array(i) > array(minidx)) then
        temp = array(i)
        array(i) = array(minidx)
        array(minidx) = temp
      end if
    end do
    
  end subroutine sort_array
  
  
  subroutine get_comparison_test(filename, moduli_w, moduli_w_base)
    use mod_global_variables, only: equilibrium_type
    use mod_equilibrium, only: set_equilibrium
    use mod_matrix_creation, only: create_matrices
    use mod_solvers, only: solve_QR
  
    character(len=*), intent(in)  :: filename 
    real(dp), intent(out)         :: moduli_w(matrix_gridpts), &
                                     moduli_w_base(matrix_gridpts)
  
    real(dp)      :: matrix_B(matrix_gridpts, matrix_gridpts)
    complex(dp)   :: matrix_A(matrix_gridpts, matrix_gridpts)
    complex(dp)   :: ev_l(matrix_gridpts, matrix_gridpts)
    complex(dp)   :: ev_r(matrix_gridpts, matrix_gridpts)
    complex(dp)   :: omega(matrix_gridpts), omega_base(matrix_gridpts)
    
    write(*, *) "  - setting up test..."
  
    !! read correct test results, store in 'omega_base'
    write(*, *) "  - reading and storing correct base solutions..."
    call read_stored_eigenvals(filename, omega_base)

    call set_equilibrium()
    write(*, *) "  - equilibrium set: ", trim(equilibrium_type)
  
    !! solve test problem 
    call create_matrices(matrix_B, matrix_A)
    write(*, *) "  - solving eigenvalue problem..."
    call solve_QR(matrix_A, matrix_B, omega, ev_l, ev_r)
  
    !! sort result and wrap up 
    write(*, *) "  - comparing results to base..."
    moduli_w = sqrt(real(omega)**2 + aimag(omega)**2)
    moduli_w_base = sqrt(real(omega_base)**2 + aimag(omega_base)**2)
    call sort_array(moduli_w)
    call sort_array(moduli_w_base)
  
  end subroutine get_comparison_test
  
  
  @test 
  subroutine test_adiabatic_homogeneous()
    use mod_global_variables, only: str_len, equilibrium_type
    
    character(len=str_len)  :: filename
    real(dp)                :: moduli_w(matrix_gridpts), moduli_w_base(matrix_gridpts)
    
    write(*, *) "Testing adiabatic homogeneous equilibrium"

    filename = results_folder // "1-adiabatic-homo.dat"
    equilibrium_type = "Adiabatic homogeneous"

    call get_comparison_test(trim(filename), moduli_w, moduli_w_base)
    @assertEqual(moduli_w, moduli_w_base, tolerance=TOL)
    
  end subroutine test_adiabatic_homogeneous
  
  
  @test 
  subroutine test_resistive_homogeneous()
    use mod_global_variables, only: str_len, equilibrium_type
    
    character(len=str_len)  :: filename 
    real(dp)                :: moduli_w(matrix_gridpts), moduli_w_base(matrix_gridpts)
    
    write(*, *) "Testing resistive homogeneous equilibrium"
    
    filename = results_folder // "2-resistive-homo.dat"
    equilibrium_type = "Resistive homogeneous"
    
    call get_comparison_test(trim(filename), moduli_w, moduli_w_base)
    @assertEqual(moduli_w, moduli_w_base, tolerance=TOL)
    
  end subroutine test_resistive_homogeneous
  
  
  @test 
  subroutine test_resistive_tearing()
    use mod_global_variables, only: str_len, equilibrium_type
    
    character(len=str_len)  :: filename 
    real(dp)                :: moduli_w(matrix_gridpts), moduli_w_base(matrix_gridpts)
    
    write(*, *) "Testing resistive tearing equilibrium"
    
    filename = results_folder // "4-resistive-tearing.dat"
    equilibrium_type = "Resistive tearing modes"
    
    call get_comparison_test(trim(filename), moduli_w, moduli_w_base)
    @assertEqual(moduli_w, moduli_w_base, tolerance=TOL)
    
  end subroutine test_resistive_tearing
  
  
  @test 
  subroutine test_resistive_tearing_flow()
    use mod_global_variables, only: str_len, equilibrium_type
    
    character(len=str_len)  :: filename 
    real(dp)                :: moduli_w(matrix_gridpts), moduli_w_base(matrix_gridpts)
    
    write(*, *) "Testing resistive tearing (flow) equilibrium"
    
    filename = results_folder // "5-resistive-tearing-flow.dat"
    equilibrium_type = "Resistive tearing modes with flow"
    
    call get_comparison_test(trim(filename), moduli_w, moduli_w_base)
    @assertEqual(moduli_w, moduli_w_base, tolerance=TOL)
    
  end subroutine test_resistive_tearing_flow
    
end module comparison_tests
  
  
    
    
